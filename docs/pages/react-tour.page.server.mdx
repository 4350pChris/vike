import { ScaffoldCallToActionTour } from './index/ScaffoldCallToAction'

## Routing

Similarly to Next.js,
we define a new page by creating a new `+Page.jsx` file.

```jsx
// /pages/index/+Page.jsx
// Environment: browser and server

import React from "react";
import { Counter } from "../components/Counter";

export { Page };

function Page() {
  return <>
    This page is rendered to HTML and interactive: <Counter />
  </>;
}
```

By default, Vike does Filesystem Routing.

```
FILESYSTEM                  URL
/pages/index/+Page.jsx      /
/pages/about/+Page.jsx      /about
```

We can also define a page's route with a *Route String* (for parameterized routes such as `/movies/@id`) or a *Route Function* (for full programmatic flexibility).

```js
// /pages/index/+route.js

// Note how the two files share the same folder `/pages/index/`; this is how Vike
// knows that `/pages/index/+route.js` defines the route of `/pages/index/+Page.jsx`.

// Route Function
export default pageContext => pageContext.urlPathname === '/';

// If we don't create a `+route.js` file then Vike does Filesystem Routing
```


## Render Control

Unlike Next.js, we control how our pages are rendered.

```jsx
// /renderer/+onRenderHtml.jsx
// Environment: server

import ReactDOMServer from "react-dom/server";
import React from "react";
import { escapeInject, dangerouslySkipEscape } from "vike/server";

export { onRenderHtml };

async function onRenderHtml(pageContext) {
  const { Page, pageProps } = pageContext;
  const viewHtml = ReactDOMServer.renderToString(
    <Page {...pageProps} />
  );

  const title = "Vite SSR";

  return escapeInject`<!DOCTYPE html>
    <html>
      <head>
        <title>${title}</title>
      </head>
      <body>
        <div id="page-view">${dangerouslySkipEscape(viewHtml)}</div>
      </body>
    </html>`;
}
```

```jsx
// /renderer/+onRenderClient.jsx
// Environment: browser

import ReactDOM from "react-dom/client";
import React from "react";

export { onRenderClient };

async function onRenderClient(pageContext) {
  const { Page, pageProps } = pageContext
  ReactDOM.hydrateRoot(
    document.getElementById("page-view"),
    <Page {...pageProps} />
  );
}
```

This control enables us to *easily* and *naturally* integrate any tool we want (Redux, GraphQL, Service Worker, Preact, ...).

So far we have seen four page-related files:
 - `+Page.*`: runs in the browser as well as in Node.js
 - `+onRenderClient.*`: runs only in the browser
 - `+onRenderHtml.*`: runs only in Node.js
 - `+route.*`: defines the page's Route String or Route Function.

Instead of creating a `+onRenderClient.jsx` and `+onRenderHtml.jsx` file for each page,
we can create `/renderer/+onRenderClient.jsx` and `/renderer/+onRenderHtml.jsx` which apply as default for all pages.

The last two files we created are actually `/renderer/+onRenderClient.jsx` and `/renderer/+onRenderHtml.jsx`,
which means that we can now create a new page just by defining a new `+Page.jsx` file (the `+route.js` file is optional).

The `/renderer/+*` files can be overridden. For example, we can override our `onRenderHtml()` and `onRenderClient()` hooks for rendering some of
our pages with a completely different UI framework such as Vue.


## Data Fetching

Let's now have a look at how to fetch data.

```jsx
// /pages/star-wars/movie/+Page.jsx
// Environment: browser and server

import React from "react";

export { Page };

function Page(pageProps) {
  const { movie } = pageProps;
  return <>
    <h1>{movie.title}</h1>
    <p>Release Date: {movie.release_date}</p>
    <p>Director: {movie.director}</p>
  </>;
}
```

```js
// /pages/star-wars/movie/+route.js
// Environment: server

// Route String
export default "/star-wars/@movieId";
```

```js
// /pages/star-wars/movie/+onBeforeRender.js
// Environment: server

import fetch from "node-fetch";

export async function onBeforeRender(pageContext) {
  // The route parameter of `/star-wars/@movieId` is available at `pageContext.routeParams`
  const { movieId } = pageContext.routeParams;

  // `+onBeforeRender.js` files run in Node.js by default; we could use SQL/ORM queries here.
  const response = await fetch(`https://swapi.dev/api/films/${movieId}`);
  let movie = await response.json();

  // Our render and hydrate functions we defined earlier pass `pageContext.pageProps` to
  // the root React component `Page`; this is where we define `pageProps`.
  const pageProps = { movie };

  // We make `pageProps` available as `pageContext.pageProps`
  return {
    pageContext: {
      pageProps
    }
  };
}
```

```js
// /renderer/+config.h.js
// Environment: build-time

// By default, `pageContext.*` is available only on the server. But our hydrate function
// we defined earlier runs in the browser and needs `pageContext.pageProps`; we use
// `passToClient` to tell Vike to serialize and make `pageContext.pageProps`
// available to the browser.
export default {
  passToClient: ['pageProps']
}
```

That's it for the tour and we have actually already seen most of the interface;
not only is Vike flexible but it's also simple to use!

<ScaffoldCallToActionTour />
