import { Link, RepoLink, ReadingRecommendation } from '@brillout/docpress'

Environment: browser.

By default, Vike does <Link text="Server Routing" href="/server-routing" />.

We opt into <Link text="Client Routing" href="/client-routing" /> by modifying `/renderer/+config.h.ts` to:
 1. Set `clientRouting: true`.
 2. Update and adapt the <Link text={<><code>onRenderClient()</code> hook</>} href="/onRenderClient" /> to
    hydrate the DOM only when rendering the first page.

> Instead of manually integrating Client Routing yourself, you can use <Link text={<><code>vike-*</code> packages</>} href="/vike-packages" /> and [Bati](https://batijs.github.io/): `vike-*` packages use Client Routing and Bati helps you scaffold projects. Bati and `vike-*` packages are going to get out of beta soon.

React example:
 - <RepoLink path='/examples/react-full-v1/renderer/+onRenderClient.tsx' />
 - <RepoLink path='/examples/react-full-v1/pages/index/+Page.tsx' /> (example of using <code>navigate()</code>)

Vue example:
 - <RepoLink path='/examples/vue-full-v1/renderer/+onRenderClient.ts' />
 - <RepoLink path='/examples/vue-full-v1/renderer/app.ts' />
 - <RepoLink path='/examples/vue-full-v1/pages/index/+Page.vue' /> (example of using <code>navigate()</code>)


## Usage & options

```js
// /renderer/+onRenderClient.js
// Environment: browser

export { onRenderClient }

import { renderToDom, hydrateDom } from 'some-ui-framework'

async function onRenderClient(pageContext) {
  // `pageContext.isHydration` is set by Vike and is `true` when the page
  // is already rendered to HTML.
  if (pageContext.isHydration) {
    // We hydrate the first page. (Since we do SSR, the first page is already
    // rendered to HTML and we merely have to hydrate it.)
    await hydrate(pageContext.Page)
  } else {
    // We render a new page. (When the user navigates to a new page.)
    await renderToDom(pageContext.Page)
  }
}
```

```js
// /renderer/+config.h.js
// Environment: build-time

export default {
  // Enable Client Routing
  clientRouting: true,

  // See "Link prefetching" section below. Default value: 'hover'.
  prefetchStaticAssets: 'viewport',

  // Whether your UI framework allows the hydration to be aborted. (Allowing Vike
  // to abort the hydration if the user clicks on a link before the hydration finished.)
  // React users should set hydrationCanBeAborted to true. (Other frameworks,
  // such as Vue, crash if the hydration is aborted.)
  hydrationCanBeAborted: true
}
```

```js
// /renderer/+onPageTransitionStart.js
// Environment: browser

export { onPageTransitionStart }

// Create custom page transition animations
async function onPageTransitionStart(pageContext) {
  console.log('Page transition start')
  // `pageContext.isBackwardNavigation` is also set at `onRenderClient(pageContext)`
  // and `onPageTransitionEnd(pageContext)`.
  console.log('Is backwards navigation?', pageContext.isBackwardNavigation)
  // For example:
  document.body.classList.add('page-transition')
}
```

```js
// /renderer/+onPageTransitionEnd.js
// Environment: browser

export { onPageTransitionEnd }

async function onPageTransitionEnd(pageContext) {
  console.log('Page transition end')
  // For example:
  document.body.classList.remove('page-transition')
}
```

```js
// /renderer/+onHydrationEnd.js
// Environment: browser

export { onHydrationEnd }

// The onHydrationEnd() hook is called after the onRenderClient() hook finishes for the
// first page the user navigates to (the onHydrationEnd() hook isn't called for
// subsequent page navigation).
async function onHydrationEnd() {
  console.log('The page is now interactive')
}
```

> Note that `pageContext` is completely discarded and created anew upon page navigation.
> That's why it's called *page*Context (and not *app*Context).

We can keep using `<a href="/some-url">` links: the Client Router automatically intercepts clicks on `<a>` elements.

We can skip the Client Router by adding the `rel="external"` attribute, e.g. `<a rel="external" href="/some/url">The Client Router won't intercept me</a>`.

We can use <Link text={<code>navigate('/some/url')</code>} href="/navigate"/> to programmatically navigate the user to a new page.

By default, the Client-side Router scrolls to the top of the page upon page change;
we can use `<a href="/some/url" keep-scroll-position />` / `navigate('/some/url', { keepScrollPosition: true })`
if we want to preserve the scroll position instead. (Useful for <Link text="Nested Layouts" href="/layouts#nested-layouts" />.)

> See [Render Modes](/render-modes) for another illustration of conditional DOM hydration.


## State initialization

Usually, when using tools such as Apollo GraphQL, Redux or Vuex, we determine the initial state of our UI on the server-side while rendering HTML, and then initialize the client-side with that initial state.

Depending on the tool, we do either one of the following:
 - We initialize the state once.
 - We re-initialize the state on every page navigation.

<ReadingRecommendation tour={true} links={['/data-fetching', '/data-fetching-tools', '/store']} />

To initialize once:

```js
// /renderer/+onRenderHtml.js
// Environment: server

export { onRenderHtml }

import { escapeInject, dangerouslySkipEscape } from 'vike/server'
import { renderToHtml } from 'some-ui-framework'
import { getInitialState } from './getInitialState'

// The `onRenderHtml()` hook is called only for the first page.
// (Whereas `onBeforeRender()` is called as well upon page navigation.)
async function onRenderHtml(pageContext) {
  const initialState = await getInitialState()

  // We use `initialState` for rendering the HTML, so that the HTML contains
  // the content of `initialState`.
  const pageHtml = await renderToHtml(pageContext.Page, initialState)

  const documentHtml = escapeInject`<!DOCTYPE html>
    <html>
      <body>
        <div>${dangerouslySkipEscape(pageHtml)}</div>
      </body>
    </html>`

  return {
    documentHtml,
    pageContext: {
      initialState
    }
  }
}
```

```js
// /renderer/+config.h.js
// Environment: build-time

export default {
  passToClient: ['initialState']
}
```

```js
// /renderer/+onRenderClient.js
// Environment: browser

export { onRenderClient }

import { initClientSide } from './initClientSide'

async function onRenderClient(pageContext) {
  // The first page is rendered to HTML and `pageContext.isHydration === true`
  if (pageContext.isHydration) {
    // `pageContext.initialState` is available here
    initClientSide(pageContext.initialState)
  } else {
    // Note that `pageContext.initialState` isn't available here,
    // since our `onRenderHtml()` hook is only called for the first page.
  }

  // ...
}
```

To initialize on every page navigation:

```js
// /renderer/+onBeforeRender.js
// Environment: server

export { onBeforeRender }

import { getInitialState } from './getInitialState'

// The `onBeforeRender()` hook is called for the first page as well as upon page navigation.
// (Whereas `onRenderHtml()` is called only for the first page.)
async function onBeforeRender() {
  const initialState = await getInitialState()
  return {
    pageContext: {
      initialState
    }
  }
}
```

```js
// /renderer/+onRenderClient.js
// Environment: browser

export { onRenderClient }

import { initClientSide } from './initClientSide'

async function onRenderClient(pageContext) {
  // We initialize the state for every page rendering. So not only
  // the first page but also any subsequent page navigation.
  initClientSide(pageContext.initialState)

  // ...
}
```

## Link prefetching

By default,
the static assets of `/some-url` are loaded as soon as the user hovers his mouse over a link `<a href="/some-url">`.
This means that static assets are often already loaded before even the user clicks on the link.

We can prefetch even more eagerly by using viewport prefetching: the links are then prefetched as soon as they appear in the viewport of the user's browser.

```js
// /renderer/+config.h.js
// Environment: build-time

export default {
  // Prefetch links as soon as they enter the viewport
  prefetchStaticAssets: 'viewport'

  // Prefetch links when the user's mouse hovers a link
  prefetchStaticAssets: 'hover'

  // Disable prefetching
  prefetchStaticAssets: false
}
```

> Viewport prefetching is disabled in development. (Because it would make Vite transpile all preloaded pages and thus siginficantly slow down development.)

To override the setting for individual links: `<a data-prefetch-static-assets="hover" href="/some-url" />` (or `data-prefetch-static-assets="false"` and `data-prefetch-static-assets="viewport"`).

We can programmatically <Link text={<code>prefetch('/some/url')</code>} href="/prefetch"/>.

> Only static assets are prefetched: the `pageContext` of pages isn't prefetched, see [#246](https://github.com/vikejs/vike/issues/246).

We can viewport prefetch for mobile users while only hover prefetch for desktop users:

```js
// For small screens, such as mobile, viewport prefetching can be a sensible strategy
export const prefetchStaticAssets = window.matchMedia('(max-width: 600px)').matches
  ? 'viewport' : 'hover'
```

```js
// Or we enable viewport prefetching for any device without a mouse: mobile and tablets (but
// not laptops that have a touch display).
export const prefetchStaticAssets = window.matchMedia('(any-hover: none)').matches
  ? 'viewport' : 'hover'
```

See also:
 - [MDN > Web API > Window > matchMedia()](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia)
 - [Stack Overflow > Detecting that the browser has no mouse and is touch-only](https://stackoverflow.com/questions/7838680/detecting-that-the-browser-has-no-mouse-and-is-touch-only/52854585#52854585)

## TypeScript

```ts
// /renderer/+onPageTransitionStart.ts
// Environment: browser

export { onPageTransitionStart }

import type { OnPageTransitionStartAsync } from 'vike/types'

const onPageTransitionStart: OnPageTransitionStartAsync = async (
): ReturnType<OnPageTransitionStartAsync> => {
  console.log('Page transition start')
  console.log('Is backwards navigation?', pageContext.isBackwardNavigation)
  document.body.classList.add('page-transition')
}
```

```ts
// /renderer/+onPageTransitionEnd.ts
// Environment: browser

export { onPageTransitionEnd }

import type { OnPageTransitionEndAsync } from 'vike/types'

const onPageTransitionEnd: OnPageTransitionEndAsync = async (
): ReturnType<OnPageTransitionEndAsync> => {
  console.log('Page transition end')
  document.body.classList.remove('page-transition')
}
```

```ts
// /renderer/+onHydrationEnd.ts
// Environment: browser

export { onHydrationEnd }

import type { OnHydrationEndAsync } from 'vike/types'

const onHydrationEnd: OnHydrationEndAsync = async (): ReturnType<OnHydrationEndAsync> => {
  console.log('The page is now interactive')
}
```
