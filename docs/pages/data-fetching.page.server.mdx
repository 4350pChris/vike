import { RepoLink, Link } from '@brillout/docpress'

> We recommend taking the <Link text="React Tour" href="/react-tour" /> or <Link text="Vue Tour" href="/vue-tour" /> before reading this guide.
> The tour explains what the files `/renderer/+onRenderHtml.js` and `/renderer/+onRenderClient.js` are about.

## `data()`

The usual way to fetch data is to use a <Link href="/data">`data()`</Link> hook.

```js
// /pages/movies/+data.js
// Environment: server

export { data }

import fetch from 'node-fetch'

async function data(pageContext) {
  // data() runs only in Node.js by default; we could use SQL/ORM queries here.
  const response = await fetch('https://movies.example.org/api')
  let movies = await response.json()

  // `movies` will be serialized and passed to the browser; we select only the data we
  // need in order to minimize what is sent to the browser.
  movies = movies.map(({ title, release_date }) => ({ title, release_date }))

  return {
    movies
  }
}
```

```js
// /renderer/+onRenderHtml.js
// Environment: server

export { onRenderHtml }

import { escapeInject, dangerouslySkipEscape } from 'vike/server'
import { renderToHtml, createElement } from 'some-ui-framework'

async function onRenderHtml(pageContext) {
  // Our data is available at pageContext.data
  const { Page, data } = pageContext
  const pageHtml = await renderToHtml(
    // We pass pageContext.data to the <Page> component
    createElement(Page, data)
  )
  /* JSX:
  const pageHtml = await renderToHtml(<Page {...data} />)
  */

  return escapeInject`<html>
    <div id='view-root'>
      ${dangerouslySkipEscape(pageHtml)}
    </div>
  </html>`
}
```

```js
// /renderer/+onRenderClient.js
// Environment: browser

export { onRenderClient }

import { hydrateDom, createElement } from 'some-ui-framework'

async function onRenderClient(pageContext) {
  const { Page, data } = pageContext
  await hydrateDom(
    // We pass pageContext.data to the <Page> component
    createElement(Page, data),
    document.getElementById('view-root')
  )
  /* JSX:
  await hydrateDom(<Page {...data} />, document.getElementById('view-root'))
  */
}
```

```js
// /pages/movies/+Page.js
// Environment: browser and server

export { Page }

// In the onRenderHtml() and onRenderClient() hooks above, we pass
// pageContext.data to the <Page> component
function Page(data) {
  const { movies } = data
  // ...
}
```


## Error handling

To gracefully handle errors, use <Link href="/render" text={<code>throw render()</code>}></Link> or <Link href="/redirect" text={<code>throw redirect()</code>}></Link>.

```js
// /pages/movie/@id/+data.js
// Environment: server

export { data }

import { render, redirect } from 'vike/abort'
import fetch from 'node-fetch'

async function data(pageContext) {
  const movieId = pageContext.routeParams.id
  const url = `https://movies.example.org/api/movie/${movieId}`
  const response = await fetch(url)
  if (response.status === 404) {
    // Render the error page and show an error message to the user
    throw render(404, `Movie with ID ${movieId} doesn't exist.`)
    /* Or redirect the user:
    throw redirect('/movie/add')
    // Or render the movie submission form while preserving the URL:
    throw render('/movie/add')
    */
  }
  // ...
}
```

> The `@id` in the path `/pages/movie/@id/+data.js` denotes a route parameter which value is available at `pageContext.routeParams.id`, see <Link href="/routing" />.

Upon `throw render(404)`, the <Link text="error page" href="/error-page" /> is rendered.

Using `throw render('/movie/add')` instead of `throw redirect('/movie/add')` is a novel technique which we explain at <Link href="/auth#login-flow" />.

## GraphQL

When using GraphQL, we define GraphQL queries/fragments on a component-level, while we fetch the GraphQL data in a single global `data()` hook.

In general, with Vike, we have full control over rendering which means that integrating GraphQL is mostly only a matter of following the official SSR guide of the tool we want to use.

- <Link href="/apollo-graphql" />
- <Link href="/relay" />
- <Link href="/urql" />

## Store (Vuex/Redux...)

When using a global store ([Vuex](https://vuex.vuejs.org/), [Redux](https://redux.js.org/), [PullState](https://lostpebble.github.io/pullstate/), ...), our components don't access the fetched data directly. Instead, our components only access the store, while the fetched data merely determines the initial state of the store.

In general, with Vike, we have full control over rendering which means that integrating a global store is mostly only a matter of following the official SSR guide of the tool we want to use.

- <Link href="/redux" />
- <Link href="/vuex" />
- <Link href="/pinia" />
- <Link href="/pullstate" />
